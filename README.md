# network_monitor
Простая программа асинхронного опроса сетевых устройств

Алгоритм
1) Создаются обработчики очередей (для разовых задач и для циклических)
2) Считывается конфигурация, очередь задач распраделяется по очередям обработчиков
3) Обработчики запускаются асинхронно
4) Опрос производится асинхронно, результаты опроса отправляются асинхронно
5) для периодических задач устанавливается внутренний таймер ожидания
6) запускается мониторинг конфигурации
7) при изменении конфигурации задачи останавливаются, очереди пересоздаются, далее с п.3

Правки v2.0
--- добавлена асинхронность (асинхронно запускаем задачи, асинхронно пишем результат)
--- добавлена работа на основе двух очередей (разовые задачи и периодические)
--- добавлено четкое разделение на обработчики разовых и периодических задач (и те и те вычитывают свои очереди)
--- добавлено завершение обработчиков при выходе из программы


----


(старый алгоритм)
Алгоритм (как задумывался, вопросы не задавал, сходу придумал именно такой алгоритм):
1) считывается файл конфигурации сетевых устройств
2) выполняется асинхронный опрос устройств
3) сохраняются выгруженные файлы конфигураций
4) выводится статистика опроса
5) программа ожидает 10 сек
6) переходим на п.1


правки v1.0
- работа с файлами не асинхронная - все лочить будет.
--- сделано специально (последовательность: "считывание конфига, опрос, сохранение результата" - синхронная, при этом сам опрос сетевых устройств асинхронный)
- не принты, а логирование использовать
--- переделал все на logging кроме самодельного diff конфигурации (logging не дружит с разноцветными буквами)
- закрытие коннекта только в try, надо в finally делать. упадет = соединение не закроется
--- реализовал даже лучше - контекстным менеджером "assync with"
- если при загрузке начальной конфигурации произошел ексепшен, то код продолжит работать, хотя ему не с чем работать.
--- вынес инициализацию модулей в _initialize_components, добавил обработку
- отслеживание изменений надо через watchdog делать, который кинет в очередь новое и оттуда все заберется, а тут цикл
--- выкинул цикл (последовательность: "считывание конфига, опрос, сохранение результата" - синхронная, при этом сам опрос сетевых устройств асинхронный)
- нет защит от keyerror, он где-то безопасно получает данные из словаря, а где-то нет.
--- добавил класс DeviceCredentials, в него считывается конфиг, дальше работа только с экземплярами класса
- в JumpHostConnector возвращает только target_conn. Правильнее вернуть еще и jump_host, вдруг он отвалится? будет висячее соединение.
--- выкинул JumpHost (не было в ТЗ, но замечание отличное!)
